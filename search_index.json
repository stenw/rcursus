[
["index.html", "Introductiecursus R Hoofdstuk1 Voorwoord", " Introductiecursus R Sten Willemsen 2021-06-09 Hoofdstuk1 Voorwoord Deze R cursus is bedoelt om niet-statistici snel op weg te helpen met R. Na het doornemen van deze tekst en het maken van de opgaven zou je in staat moeten zijn om eenvoudige statistische analyses in R uit te voeren en om de data in een vorm te gieten die daar geschikt voor is. Hierbij is gekozen voor de snelste route die naar dit doel leidt. Dit betekent dat veel details onbesproken blijven, veel elementaire concepten van de programmeer taal R onbehandeld. Ook wordt er nauwelijks ingegaan op de statistische achtergrond van de statistische toetsen. Dit zijn bewuste keuzes. In de eerste plaats is het zo dat vaak de tijd ontbreekt om op al deze dingen in te gaan. Verder is het mijn ervaring dat waanneer je echt vanaf de basis begint in een dergelijke cursus het niet beklijft. Dit omdat de rol die de verschillende details in het geheel spelen nog niet duidelijk zijn Het eindresultaat is dan vaak dat een cursist aan het eind nog niet in staat is om echt zelfstandig iets te doen. En als er niets met de opgedane kennis gebeurt zal deze weer wegzakken. Het is wel aan te bevelen om, wanneer je echt wil leren zelf te programmeeren in R, op een later tijdstip wel een cursus te volgen of een boek te lezen waarin een en ander wel op een meer fundamenteler niveau wordt behandeld. Ik ben van mening dat dan, omdat duidelijker is hoe verschillende zaken van praktisch nut kunnen zijn, alles veel beter op zijn plaats valt. Om de toegankelijk verder te vergroten is er verder voor gekozen om deze tekst geheel in het Nederlands te schijven. Omdat de statistische literatuur voornamelijk Engelstalig is kan dit her en der wat gekunsteld overkomen. Dit is denk ik onvermijdelijk. "],
["intro.html", "Hoofdstuk2 Introductie 2.1 Waarom R 2.2 Installatie van R en RStudio 2.3 Interface van RStudio", " Hoofdstuk2 Introductie 2.1 Waarom R R is op dit moment het pakket dat het meest wordt gebruikt door statistici. Deze populariteit is te danken aan het feit dat het enerzijds een pakket is dat volledig gericht is op data-analyse maar anderzijds een volledige programmeertaal is. Dit in tegenstelling tot enerzijds SPSS en SAS waarin slechts in beperkte mate geprogrammeerd kan worden en aan de andere kant bijvoorbeeld Python een algemene programmeertaal die veel gebruikt wordt voor data-analyse maar die hier niet van het begin af aan voor is ontworpen. Een kenmerk van R dat in belangrijke mate aan deze populariteit heeft bijgedragen is ongetwijfeld dat dit programma volledig gratis is. Ook is de broncode open en in het publieke domein. Iedereen kan dus (in principe) zelf wijzigingen aanbrengen en voorstellen deze wijzigingen ook in de openbare distributie van R aan te brengen. Dit betekent in principe ook dat er geen fabrikant van R is bij wie je terecht kunt als je vragen hebt. Gelukkig zijn er ook genoeg andere bronnen waar je voor ondersteuning terecht kunt. R werkt met een modulair systeem: er is slechts een beperkte basis functionaliteit, maar R is uitbreidbaar door middel van verschillende packages. Er is tegenwoordig een duizelingwekkende hoeveelheid van deze uitbreidingspakketten. De kwaliteit kan echter wisselend zijn (al is er wel een zekere mate van controle op de packges die via de R-site worden aangeboden). 2.2 Installatie van R en RStudio Voordat we met R kunnen werken moeten we het programma op de computer installeren. Het werkt gemakkelijk als we daarnaast nog een tweede programma Rstudio installeren. Dit is een apart programma dat het werken met R een stuk gebruiksvriendelijker maakt. Zo’n programma wordt ook wel een Integrated Development Environment of IDE genoemd. Er zijn meerdere IDEs voor R beschikbaar maar we zullen hier alleen op RStudio ingaan. R is te downloaden op https://cran.r-project.org/. /). Voor windowscomputers en Apples is het het makkelijkst om te kiezen voor de binaire distributie (hiermee wordt bedoeld dat je het pakket niet meer zelf hoeft te compileren). Klik voor een windowscomputer op ‘download R for Windows’. Kies dan voor ‘base’ om het installatieprogramma te downloaden. Om dit programma te starten open je eerst de download map. Klik nu rechts op het programma icoon en kies ‘Run as Administrator’. Er wordt nu gevraagd om de taal waarin het programma je door de installatie leidt; Dit heeft geen gevolgen voor de taal waarin R zal werken. Volg nu de verdere stappen in het programma; Je kunt eigenlijk altijd voor de standaard opties kiezen die al zijn aangevinkt. RStudio is te downloaden op https://www.rstudio.com/products/RStudio. Kies op deze pagina voor ‘Download RStudio Desktop’ en vervolgens voor de gratis versie. Vervolgens kun je het installatieprogramma voor windows-pc’s downloaden. Open de map waarin je het gedownload hebt en dubbelklik op het installatiebestand. Tijdens de installatie kunnen weer de voorgeselecteerde opties gekozen worden. 2.3 Interface van RStudio Wanneer je RStudio opent is het scherm in een aantal gedeelten (panelen) onderverdeeld. Een paneel kan meerdere tabjes hebben met elk een eigen functie. We zullen hier de belangrijkste behandelen. Linksonder vind je de R prompt (de Console); Hier kun je je R-commando’s typen en R geeft hier vervolgens de resultaten van die commando’s weer. RStudio onthoud welke commando’s je recentelijk hebt uitgevoerd. Met de pijltjestoetsen kun je door deze geschiedenis bladeren. Toch is echter alleen bedoeld voor de korte termijn. Wanneer je je R commando’s langer wilt bewaren, zul je een script (eigenlijk een programmaatje) moeten maken. Het gedeelte linksboven is de editor voor deze scripts. Wanneer je RStudio voor het eerst opstart bestaat dit paneel nog niet maar het zal tevoorschijn komen wanneer je een bestaand script opent of via het menu of de sneltoetscombinatie Ctrl+Shift+N kiest om een nieuw script te openen. Een script is een reeks commando’s om bijvoorbeeld een analyse uit te voeren. Je kunt een script opslaan door te kiezen voor ‘save’ of ‘save as’ in het ‘file’ menu. Zo blijft bewaard welke commando’s je precies hebt uitgevoerd en dus ook bijvoorbeeld hoe je precies tot je conclusies van je analyse komt. Een R script heeft meestal de extensie .R en is een gewoon tekst bestand (dus te openen in elke tekst editor). Je kunt het hele script uitvoeren door tegelijkertijd de toetsen Ctrl+Alt+R in te drukken. Ook kun je gedeeltes van een script uitvoeren door deze te selecteren en Ctrl+Enter in te drukken. Wanneer je deze toetsen combinatie gebruikt als je niet eerste een gedeelte van een script hebt geselecteerd maar je cursor wel in dit gedeelte van het beeldscherm staat wordt de regel waar de cursor staat uitgevoerd. Wanneer je meerdere scripts tegelijkertijd opent komen deze naast elkaar in verschillende ‘tabs’ te staan. Rechtsonder vind je een tab ‘Files’ met bestanden in de werkdirectory en een tab ‘Plots’ waarin plaatjes die je maakt worden weergegeven. In het paneel rechtsboven vind je het tabje ‘History’ waarin de commando’s staan die het meest recent zijn uitgevoerd. Ook vind je hier het tabblad ‘Environment’. Dit geeft alle objecten weer die op dit moment gedefinieerd zijn. We komen hier later op terug. "],
["basics.html", "Hoofdstuk3 Basis van R 3.1 R als rekenmachine 3.2 Variabelen 3.3 library en packages 3.4 Documentatie", " Hoofdstuk3 Basis van R 3.1 R als rekenmachine Een van de meest eenvoudige commando’s die je met R kunt uitvoeren zijn de standaard wiskundige bewerkingen: 1+1 ## [1] 2 1-1 ## [1] 0 0 ## [1] 0 2*3 ## [1] 6 2/3 ## [1] 0.6666667 In het bovenstaande geeft het teken ‘&gt;’ de R prompt weer. Hiermee wordt in de console aangegeven dat R klaar is voor een nieuwe opdracht. De regels daartussen zijn de uitkomsten die R heeft berekend. Veel van de functionaliteit in R komt van functies. Zo kent R de volgende wiskundige bewerkingen cos(3.1415) ## [1] -1 exp(0) ## [1] 1 log(1) ## [1] 0 We zullen later dieper ingaan op functies. 3.2 Variabelen We kunnen het resultaat ook toewijzen aan een variabele. Het wordt dan niet weergegeven maar we geven het resultaat een naam opdat we er later verder mee kunnen werken. Dit gaat met &lt;-. Bijvoorbeeld: five &lt;- 3+2 five ## [1] 5 five + 1 ## [1] 6 Elke variabele heeft een class die voor een groot gedeelte bepaalt wat we met de variabele kunnen doen. 3.3 library en packages Zoals al vermeld is de taal R modulair en uitbreidbaar met pakketten. Je kunt een package laden met het commando library(). Als we dus bijvoorbeeld het package survival willen laden (om overlevingsanalyse te doen) dan typen we: library(survival) Enkele interessante packages zijn: gamlss (voor het maken van referentiecurven), lme4 (voor het analyseren van herhaalde metingen) en mice (multipele imputatie). 3.4 Documentatie De functies help en ? kunnen gebruikt worden om de documentatie over een bepaald onderwerp (meestal een functie) te lezen. De package waarin de functie word gedefinieerd moet wel geladen zijn. Met help.search en ?? kunnen we meer algemeen in de documentatie van geïnstalleerde packages zoeken. &gt;?library &gt;help(install.packages) &gt;help.search(&#39;logistic regression&#39;) "],
["data.html", "Hoofdstuk4 Een data bestand 4.1 Inlezen van een bestand 4.2 data.frames 4.3 vectoren en datatypen 4.4 lists 4.5 factors 4.6 Missende waarden", " Hoofdstuk4 Een data bestand 4.1 Inlezen van een bestand Als je met R wilt werken is dat waarschijnlijk omdat je een databestand wilt analyseren. Het is daarom handig om het gebruik van R ook aan de hand van een databestand toe te lichten. Laten we een bestand laden1: library(foreign) mijndata &lt;- read.spss(file=&#39;https://github.com/stenw/ep03logistic/blob/master/data-raw/pain.sav?raw=true&#39;, to.data.frame = TRUE) 4.2 data.frames Wanneer we dit commando op deze manier uitgevoerd hebben zal wordt de data ingelezen en opgeslagen onder de naam mijndata. mijndata is een zogenaamde data.frame. Dit is een rechthoekige tabel waarin elke kolom een variabele bevat en elke regen een observatie. De variabele mijndata zal ook verschijnen in het tabblad rechtsboven. Naast de naam van de data staat hoeveel observaties en hoeveel variabelen de data.frame bevat. We kunnen het de data bekijken door op het icoontje te klikken dat ernaast staat. Een andere manier om de data te bekijken is door het commando View(mijndata) rechtstreeks in de terminal te typen. We zien dat de eerste vier variabelen het patientnummer, de behandeling, het geslacht en de leeftijd zijn (ptno, treatm, sex en age). Om te werken met één van de variabelen in een data.frame typen we eerst de naam van de data.frame, een dollarteken en vervolgens de naam van de variabele zelf. Wanneer we dus het commando: mijndata$age in de console typen worden alle leeftijden weergegeven. We kunnen de gemiddelde leeftijd berekenen met de functie mean. mean(mijndata$age) ## [1] 53.52 4.3 vectoren en datatypen Elke variabele in de data.frame is een vector. Dit zijn een aantal waarden van het zelfde datatype (ofwel de mode2). De belangrijkste datatypen in R zijn3: mode beschrijving character: logical: numeric: list: tekst, bijvoorbeeld: ‘man’, ‘vrouw’, ‘gecensureerd’, etc. waar of niet waar. TRUE, FALSE een numerieke waarde 1, 1.2, 1e12 (dwz 10 tot de macht 12) zie hieronder Vectoren van deze datatypen zijn de meest elementaire datastructuren in R. Alle andere data structuren (zoals de data.tables) zijn opgebouwd uit vectoren. In R zijn er ook geen structuren kleiner dan een vector. Een enkel getal wordt niet anders behandeld dan een vector van 10 getallen; het enkele getal is gewoon een vector met lengte één. De lengte van een vector kunnen we overigens verkrijgen door middel van de functie length(). We kunnen een vector maken door middel van de functie c(). (De c staat voor ‘concatenate’, ‘coerce’of ’combine’) c(1, 2, 3) ## [1] 1 2 3 c(&#39;aap&#39;, &#39;noot&#39;, &#39;mies&#39;) ## [1] &quot;aap&quot; &quot;noot&quot; &quot;mies&quot; c(&quot;dubbele aanhalingstekens&quot;, &quot;werken&quot;, &#39;net als&#39;, &#39;enkele&#39;) ## [1] &quot;dubbele aanhalingstekens&quot; &quot;werken&quot; ## [3] &quot;net als&quot; &quot;enkele&quot; c(TRUE, FALSE) ## [1] TRUE FALSE In de uitvoer zie je dat R tussen rechte haken het nummer aangeeft van het eerste element op elke rij. Dit maakt het makkelijker om naar een bepaald element te refereren. We kunnen met vectoren rekenen op dezelfde manier als we dat met gewone getallen doen. De bewerkingen worden elementsgewijs uitgevoerd. c(1, 2, 3) * c(4, 5, 6) ## [1] 4 10 18 Wanneer je probeert een vector te maken die uit verschillende datatypen bestaat worden zullen ze omgezet naar een datatypen die alle onderdelen kan bevatten. Bijvoorbeeld: c(&quot;elf&quot;, 12) ## [1] &quot;elf&quot; &quot;12&quot; Het tweede element van de resulterende vector is nu een character waarde. Het is aan te bevelen om niet te vertrouwen op deze impliciete conversie maar daarvoor speciale functies of as.character() te gebruiken. 4.4 lists De elementen van een vector zijn altijd van hetzelfde data type. Een list onderscheidt zich van een vector doordat deze ook verschillende datatypen kan bevatten. We kunnen een list maken met de functie list lijst1 &lt;- list(&quot;elf&quot;, 12) lijst2 &lt;- list(c(1, 2, 3), c(&#39;aap&#39;, &#39;noot&#39;)) We kunnen de elementen van een list ook een naam geven. lijst3 &lt;- list(getallen=c(1, 2, 3), chars=c(&#39;aap&#39;, &#39;noot&#39;)) Een list kan zelf ook weer andere lists bevatten. lijst4 &lt;- list(getallen=c(1, 2, 3), chars=c(&#39;aap&#39;, &#39;noot&#39;), sublijst=list(1,&#39;a&#39;)) 4.5 factors Een factor is een speciale vector voor categorische data. De vector bevat verschillende getallen voor elke categorie. Bij elke waarde hoort een ‘label’ om aan te geven wat de verschillende codes betekenen. Factoren worden veel gebruikt wanneer we modellen schatten voor categorische data. Een voordeel van het gebruik van een factor in plaats van character is dat we het aantal mogelijke waarden kunnen beperken ook gaan er minder makkelijk dingen mis door typefouten. We kunnen een factor variabele maken door middel van de functie factor(). factor(c(&#39;man&#39;, &#39;vrouw&#39;, &#39;man&#39;)) ## [1] man vrouw man ## Levels: man vrouw Wanneer een factor wordt weergegeven geeft R ook aan welke mogelijkheden er zijn. Dit worden de ‘levels’ genoemd. Een belangrijk verschil tussen een data.frame en een list is dat de elementen (kolommen) van een data.frame altijd allemaal even lang zijn. Dit is niet het geval bij een list. 4.6 Missende waarden Wanneer de waarde van een variabele ontbreekt zal R dat aangeven met ‘NA’. Dit betekent meestal dat de waarde wel bestaat maar dat we niet weten wat deze waarde is. Wanneer een waarde niet berekend kan worden (dwz. er wordt een ongeldige wiskundige bewerking gedaan) dan zal de waarde NaN zijn (dit staat voor ‘Not a Number’). Tenslotte wordt ook nog de waarde NULL gebruikt om aan te geven dat de waarde (nog) niet is gedefinieerd. In deze cursus zullen we vooral te maken hebben met ontbrekende data, dus met NA. Het laden van data bestanden wordt later meer uitgebreid besproken.↩ Gerelateerd aan de mode zijn de storage.mode en de type. Zie ?mode.↩ Er zijn meer datatypen maar die laten we hier onbesproken.↩ "],
["subsetting.html", "Hoofdstuk5 Selecties 5.1 Indexeren in een vector 5.2 Selecteren van variabelen en observaties in een data.frame 5.3 Selecties maken in een list", " Hoofdstuk5 Selecties Vaak willen we een iets weten over bepaalde variabelen voor een bepaalde patiëntengroep. (We willen bijvoorbeeld het gemiddelde weten van de variabelen leeftijd en gewicht voor de vrouwen in het databestand). Het is dus belangrijk om bepaalde variabelen en bepaalde observaties te kunnen selecteren. We beginnen met het laten zien hoe we selecties kunnen maken van observaties binnen één variabele (een vector). Daarna laten we zien hoe het selecteren van een variabelen en observaties in een data.frame werkt. 5.1 Indexeren in een vector Als voorbeeld zullen we de leeftijden van de patiënten in de data.frame mijndata gebruiken; laten we deze vector dus een naam geven. leeftijden &lt;- mijndata$age 5.1.1 Selecties maken gebaseerd op positie in een vector De eenvoudigste manier om waarden te selecteren is door middel van de positie binnen de vector. Dit kunnen we doen door de positie van de patiënt waarvan we de leeftijd willen weten tussen rechte haken achter de naam van de vector te plaatsen. Wanneer we de leeftijd van de eerste patiënt in de data.frame willen weten kunnen we dat doen door: leeftijden[1] ## [1] 58 Dit kan ook voor meerdere patiënten tegelijkertijd. selectie &lt;- leeftijden[c(2, 3)] selectie ## [1] 68 61 Wanneer we een vector van negatieve gehele getallen gebruiken dan zullen we juist alle patiënten selecteren behalve die op de aangegeven posities: leeftijden[-c(1, 2, 3)] ## [1] 37 80 51 39 61 58 42 61 66 66 79 72 53 70 59 60 32 48 50 52 41 61 51 68 38 ## [26] 61 55 45 56 33 50 43 70 59 51 78 64 64 53 55 37 51 73 42 66 35 51 26 58 71 ## [51] 57 73 63 56 45 55 64 26 51 23 55 53 29 69 54 34 59 70 77 74 43 58 40 45 64 ## [76] 46 65 35 40 67 52 46 56 35 40 54 36 56 45 55 52 68 52 35 40 47 64 5.1.2 Selecties maken gebaseerd op een conditie (waar/onwaar) De tweede manier om waarden te selecteren met een vector logicals (Dat wil zeggen een vector TRUE/FALSE waarden) tussen de rechthoekige haken. Op deze manier worden alleen die waarden geselecteerd waarbij de waarde tussen de haken TRUE is. selectie[c(TRUE, FALSE)] ## [1] 68 Deze manier van selecteren is vooral nuttig wanneer er een vergelijking tussen de haken wordt geplaatst leeftijden[mijndata$sex==&#39;Female&#39;] ## [1] 68 37 79 60 48 50 52 41 68 61 56 33 43 70 51 35 58 56 45 26 51 23 77 45 65 ## [26] 67 46 56 52 35 mijndata$ptno[leeftijden&gt;65] ## [1] 2 5 12 13 14 15 17 27 36 39 46 48 53 55 67 71 72 73 83 95 5.1.3 Selecties maken met een naam Wanneer de waarden van een vector allemaal een naam hebben kunnen we deze ook gebruiken om elementen te selecteren. bp_met_naam &lt;- c(sys=135, dia=85) bp_met_naam[&#39;dia&#39;] ## dia ## 85 5.2 Selecteren van variabelen en observaties in een data.frame Het selecteren van elementen van een data.frame gaat op dezelfde manier als bij een vector. Nu staan er twee waarden binnen de rechte haken gescheiden van elkaar door een komma. Het eerste getal heeft betrekking op de observaties (rijen) en het tweede op de variabelen (kolommen). We kunnen dus de eerste twee waarden van de derde variabele een de dataset (het geslacht) bekijken door middel van de syntax: mijndata[c(1, 2), 3] ## [1] Male Female ## Levels: Male Female Wanneer de eerste of de tweede positie blanco worden gelaten worden alle rijen respectievelijk kolommen geselecteerd. mijndata[, 3] # geslacht voor alle patienten ## [1] Male Female Male Female Male Male Male Male Male Male ## [11] Male Male Male Female Male Male Male Male Female Male ## [21] Female Female Female Female Male Male Female Male Female Male ## [31] Male Female Female Male Female Female Male Male Male Male ## [41] Male Male Male Male Female Male Male Male Female Male ## [51] Male Female Male Male Male Male Female Female Male Male ## [61] Female Female Female Male Male Male Male Male Male Male ## [71] Male Female Male Male Male Male Female Male Male Female ## [81] Male Male Female Male Female Male Male Male Male Male ## [91] Female Male Male Male Male Female Female Male Male Male ## Levels: Male Female mijndata[c(1,2), ] # alle variabelen voor de eerste twee patienten ## ptno treatm sex age height weight comorb painbl painfu race ## 1 1 Placebo Male 58 190 97 ja 45 64 Asian ## 2 2 Placebo Female 68 171 61 ja 45 68 Asian mijndata[c(-3,-4), &#39;sex&#39;] # we kunnen ook negatieve getallen en namen gebruiken ## [1] Male Female Male Male Male Male Male Male Male Male ## [11] Male Female Male Male Male Male Female Male Female Female ## [21] Female Female Male Male Female Male Female Male Male Female ## [31] Female Male Female Female Male Male Male Male Male Male ## [41] Male Male Female Male Male Male Female Male Male Female ## [51] Male Male Male Male Female Female Male Male Female Female ## [61] Female Male Male Male Male Male Male Male Male Female ## [71] Male Male Male Male Female Male Male Female Male Male ## [81] Female Male Female Male Male Male Male Male Female Male ## [91] Male Male Male Female Female Male Male Male ## Levels: Male Female We moeten opletten wanneer we één enkele kolom van een data.frame selecteren zoals hierboven. Het resultaat is dan zelf geen data.frame meer maar een vector. Wanneer we dit willen voorkomen gebruiken we drop=FALSE. mijndata[, 3, drop=FALSE] # data.frame met een variabele ## sex ## 1 Male ## 2 Female ## 3 Male ## 4 Female ## 5 Male ## 6 Male ## 7 Male ## 8 Male ## 9 Male ## 10 Male ## ... ## ## 92 Male ## 93 Male ## 94 Male ## 95 Male ## 96 Female ## 97 Female ## 98 Male ## 99 Male ## 100 Male 5.2.1 Dubelle haken en het dollarteken Er is nog een methode om variabelen te selecteren uit een data.frame die we al eerder gezien hebben, namelijk door middel van het dollarteken (‘$’). Het resultaat is op deze manier altijd een vector. mijndata$treatm # data.frame met een variabele ## [1] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [10] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [19] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [28] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [37] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [46] Placebo Placebo Placebo Placebo Placebo Active Active Active Active ## [55] Active Active Active Active Active Active Active Active Active ## [64] Active Active Active Active Active Active Active Active Active ## [73] Active Active Active Active Active Active Active Active Active ## [82] Active Active Active Active Active Active Active Active Active ## [91] Active Active Active Active Active Active Active Active Active ## [100] Active ## Levels: Placebo Active In plaats van het de notatie met het dollar teken kunnen we ook dubbele haken gebruiken (de naam komt dan wel tussen aanhalingstekens net als bij enkele haken). Ook kunnen we indexeren met een positie. mijndata[[&#39;treatm&#39;]] ## [1] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [10] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [19] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [28] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [37] Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo Placebo ## [46] Placebo Placebo Placebo Placebo Placebo Active Active Active Active ## [55] Active Active Active Active Active Active Active Active Active ## [64] Active Active Active Active Active Active Active Active Active ## [73] Active Active Active Active Active Active Active Active Active ## [82] Active Active Active Active Active Active Active Active Active ## [91] Active Active Active Active Active Active Active Active Active ## [100] Active ## Levels: Placebo Active mijndata[[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 Het is niet mogelijk om met dubbele haken meer dan één element tegelijkertijd te selecteren. Het resultaat is altijd een vector (en geen data.frame meer). 5.3 Selecties maken in een list Om selecties te maken in een list kunnen we zowel de enkele rechte haken, de dubbele rechte haken als het dollarteken gebruiken. Het gebruik van de enkele rechte haken werkt eigenlijk op dezelfde manier als dat bij een vector werkt. mijnlijst &lt;- list( foo=c(1,2, 3), bar=c(&#39;a&#39;, &#39;b&#39;), baz=list(TRUE, c(2, 4)) ) mijnlijst[c(1,3)] ## $foo ## [1] 1 2 3 ## ## $baz ## $baz[[1]] ## [1] TRUE ## ## $baz[[2]] ## [1] 2 4 mijnlijst[c(1,2,3)==2] ## $bar ## [1] &quot;a&quot; &quot;b&quot; mijnlijst[&#39;bar&#39;] ## $bar ## [1] &quot;a&quot; &quot;b&quot; We kunnen ook het dollarteken en de dubbele haken ook gebruiken voor een list. Er zijn twee belangrijke verschillen tussen het gebruik van enkele en dubbele haken: 1. Met dubbele haken kunnen we maar één element tegelijkertijd selecteren. 2. Het resultaat van de selectie met de dubbele haken is het element zelf, terwijl het resultaat van een relectie met enkele rechthoekige haken een list is met de geselecteerde elementen. mijnlijst[[1]] ## [1] 1 2 3 mode(mijnlijst[[1]]) # een vector ## [1] &quot;numeric&quot; mode(mijnlijst[1]) # een list met een enkel element nl een numerieke vector ## [1] &quot;list&quot; "],
["functies.html", "Hoofdstuk6 Functies 6.1 Wat zijn functies 6.2 Het gebruik van functies 6.3 Functies met meerdere argumenten. Gebruik van argumentnamen 6.4 Vervangingsfuncties 6.5 Ellips (…)", " Hoofdstuk6 Functies De kracht van R zit voor een groot deel in het gemak waarmee eigen functies kunnen worden gemaakt. Wanneer men pas begint te werken in R zijn mensen vaak huiverig om functies te maken. Men werkt dan zoals men dat gewent is uit bijvoorbeeld SPSS. Wanneer men een script heeft gemaakt voor een bepaalde variabele (zeg CRL) en men wil dan eenzelfde analyse ook toepassen op andere variabelen (bijvoorbeeld EV en TAL) kopieert men het script en vervangt de namen van de variabelen. Door het kopiëren en plakken kunnen er echter fouten gemaakt worden (vooral als het script lang is en er op verschillende plekken namen moeten worden vervangen). Nog lastiger wordt het als men iets in het script wil veranderen (of bijvoorbeeld een fout wil herstellen). Dit moet nu voor alle afzonderlijke scripts voor alle variabelen apart gebeuren. Door te werken met functies kunnen fouten worden voorkomen en kan men zich veel werk besparen. 6.1 Wat zijn functies Hoewel we nog geen functies hebben gemaakt hebben we wel al veel met functies gewerkt. Bijvoorbeeld de functie, log om een natuurlijke logaritme uit te rekenen ofread.spss om spss data te laden. Eigenlijk is alle functionaliteit van R gevat in de verschillende functies die er zijn. Maar wat is nu precies een functie. Eigenlijk is een functie code - dat wil zeggen een stukje van een programma - waaraan een naam is gegeven zodanig dat het opnieuw te gebruiken is wanneer dat nodig is. Een functie in R ziet er als volgt uit. function (arguments) {body} De code die we willen uitvoeren staat in de body. Op de argumenten van de functie komen we later terug. 6.2 Het gebruik van functies We zullen functies toelichten aan de hand van een eenvoudig voorbeeld. Stel dat we het kwadraat van vijf willen uitrekenen; dit kan met de code 5^2. Als we dit kwadraat erg vaak gebruiken zouden we hier een functie voor kunnen gebruiken.4 kwadraat&lt;-function(){ 5^2 } We hebben nu een functie gemaakt die het kwadraat van vijf uitrekent. Elke keer als we dit kwadraat nodig hebben kunnen we de functie gebruiken: kwadraat() ## [1] 25 6.2.1 Argumenten en return-waarden We kunnen nu niet zo heel veel doen met deze functie. Het zou handiger zijn als deze functie ook het kwadraat van andere getallen zou kunnen uitrekenen. Hiervoor gebruiken we de argumenten. Dit is een variabele die in het stukje code wordt gebruikt, die bij het aanroepen van de functie wordt vervangen door een bepaalde waarde. Het is weer handiger dit te laten zien met een voorbeeldje: kwadraat&lt;-function(grondtal){ grondtal^2 } kw &lt;- kwadraat(4) kw ## [1] 16 De bovenstaande functie is natuurlijk heel eenvoudig. Hij bestaat slechts uit een enkele regel. In de praktijk zou je hier waarschijnlijk helemaal geen functie voor gebruiken. Toch bevat dit voorbeeld alle ingrediënten van functies. Ze hebben (meestal) een naam, in dit geval kwadraat; argumenten, in dit geval grondtal; en een zogenaamde return-waarde. De waarde die het resultaat is van de functieoproep die hier in de variabele kw wordt opgeslagen. De return-waarde is wanneer we niets anders aangeven het resultaat van de laatste regel van de functie. We kunnen de return waarde ook expliciet maken door gebruik te maken van het keyword return. kwadraat&lt;-function(grondtal){ k&lt;-grondtal^2 return(k) } kw &lt;- kwadraat(4) kw ## [1] 16 6.3 Functies met meerdere argumenten. Gebruik van argumentnamen Het is mogelijk functies te maken met meerdere argumenten: kwadraten&lt;-function(grondtal1, grondtal2){ list(antwoord1=grondtal1^2, antwoord2=grondtal2^2) } kwadraten(4, 5) ## $antwoord1 ## [1] 16 ## ## $antwoord2 ## [1] 25 Wanneer er meerdere argumenten zijn kan het lastig zijn om te onthouden welk argument wat deed. Daarom kunnen we de in de functie oproep ook de naam van de argumenten gebruiken. kwadraten(grondtal1=6, grondtal2=8) ## $antwoord1 ## [1] 36 ## ## $antwoord2 ## [1] 64 Voor de argumenten waarvan we de naam niet gebruiken is nog steeds de positie bepalend. Bovenstaande functieoproep zou dus ook als volgt gedaan kunnen worden: kwadraten(6, grondtal2=8) ## $antwoord1 ## [1] 36 ## ## $antwoord2 ## [1] 64 6.4 Vervangingsfuncties Soms kun je functies tegenkomen waarvan de naam eindigt op &lt;- bijvoorbeeld is.na&lt;- Dit zijn zogenaamde vervangingsfuncties of in het Engels replacement functions. Het ‘pijltje’ aan het einde van de naam geeft aan dat deze functies aan de linkerkant van een assignment gebruikt kunnen worden. Zo kan is.na&lt;- op de volgende manier gebruikt worden om elementen van een vector missend te maken: een_vector &lt;- 1:5 is.na(een_vector) &lt;- 2 print(een_vector) ## [1] 1 NA 3 4 5 6.5 Ellips (…) Soms bevat de lijst met parameters van een functie drie puntjes (Dit wordt een ellips genoemd.) Dit geeft aan dat er een onbepaald aantal extra ongenaamde parameters aan de functie gegeven kunnen worden. Veel gebruikte functies met een ellips in de parameter lijst zijn: min, max en cat, maar er zijn er vele andere. Vaak wordt de ellips gebruikt om parameters door te geven aan een andere functie. Zie bijvoorbeeld het onderstaand voorbeeld waar de functie plot_regline de kleur van de punten (maar evt ook andere argumenten) doorgeeft aan de plot functie: plot_regline&lt;- function(x, y, ...){ lm1 &lt;- lm(y~x) plot(x, y, ...) abline(lm1) } plot_regline(c(2,3,4), c(3,4,2), col=&#39;red&#39;) In dit geval is het maken van een variabele natuurlijk handiger.↩ "],
["control-flow.html", "Hoofdstuk7 Control flow 7.1 Het if-statement 7.2 for-loops 7.3 while en repeat loops", " Hoofdstuk7 Control flow Vaak is het niet zo dat we een programma kunnen schrijven waarvan alle regels in alle gevallen eenvoudigweg één voor één hoeven te worden uitgevoerd. Vaak hangt wat er moet worden gedaan (of hoe vaak we iets doen) af van de bepaalde variabelen. In dit hoofdtuk bespreken we de constructies die hiervoor in R bestaan. 7.1 Het if-statement De eenvoudigste (en waarschijnlijk meest gebruikte) om een gedeelte van een syntax contitioneel uit te voeren is een if-statement. Dit ziet er als volgt uit. if (voorwaarde){ code1 } else { code2 } Hierbij wordt de code tussen het eerste paar accolades alleen uitgevoerd als de voorwaarde waar is en de de code tussen het tweede paar accolades (na else) aleen wanneer de voorwaarde onwaar is. Het else keyword en de bijbehorende tweede paar accolades is overigens optioneel. Een voorbeeld is: if (x &gt;= 0){ rtx &lt;- sqrt(X) } else { warning(&#39;Cannot take the root of a negative number - set to zero&#39;) rtx &lt;- 0 } De voorwaarde moet altijd resulteren in één TRUE of FALSE. Wanneer dit resulteerd in een vector zal alleen de eerste waarde gebruikt worden. 7.2 for-loops Soms willen een aantal statements een aantal keren herhalen. Hiervoor bestaat een for-loop (lus). Dit ziet er als volgt uit: for (index in vector) { code } De variabele index zal de waarden in de vector één voor één aannemen en voor elk van de waarde wordt de code tussen de accolades uitgevoerd. Hieronder een eenvoudig voorbeeld: for (i in c(1, 2, 3)) { print(sqrt(i)) } ## [1] 1 ## [1] 1.414214 ## [1] 1.732051 Binnen een for-loop kunnen de commando’s next en break gebrikt worden. Met next wordt de de indexvariabele meteen opgehoogd en beginnen we meteen aan de volgende itertie van de loop. De rest van de code vinnen de accolades wordt niet meer uitgevoerd. Met break verlaten we de loop onmiddelijk. We zullen het gebruik van next en break weer illustreren aan de hand van een voorbeeld. for (i in c(1, 2, 3, 4, 5)) { print(i) j&lt;- sqrt(i+1) if (i==2) { next } if (i==5) { break } print(j) } ## [1] 1 ## [1] 1.414214 ## [1] 2 ## [1] 3 ## [1] 2 ## [1] 4 ## [1] 2.236068 ## [1] 5 7.3 while en repeat loops Andere control statements zijn de while- en repeat-loops. De while loop ziet er als volgt uit: while (conditie) { code } In een while loop wordt de code tussen de accolades uitgevoerd zozang de voorwaarde tussen de ronde haakjes waar is. Elke keer dat de code tussen de accolades in zijn geheel doorlopen is wordt de voorwaare weer gecontroleerd en wanneer hij waar is wordt de code nogmaals uitgevoerd. Dit herhaaldt zich totdat de conditie FALSE wordt. Het laatste statement die we behandelen is repeat. Dit statement ziet er als volgt uit: repeat { code } Het repeat statement is vergelijkbaar met while. Er is echter geen voorwaarde die gecontroleerd kan worden. De code tussen de accolade wordt hier altijd uitgevoerd en de lus wordt alleen verlaten waneer we een break statement tegenkomen. Dit is ook de enige manier waarop de lus verlaten wordt. "],
["data-frames-importeren.html", "Hoofdstuk8 Data frames importeren", " Hoofdstuk8 Data frames importeren Vaak zal de data die we willen gebruiken niet in ‘R-formaat’ staan maar in een ander formaat. We zullen deze data dan moeten importeren. Veel functionaliteit hiervoor is opgenomen in het foreign package. Om data te openen uit spss kun je het commando read.spss uit dit paket gebruiken. De syntax is: read.spss(file=‘path/to/file/thespssfile.sps’, to.data.frame = TRUE) Met het argument to.data.frame geven we aan dat we het resultaat als een data.frame willen ontvangen. Een ander formaat dat veel wordt gebruikt zijn excel sheets; hiervoor kunnen we de functie read_excel uit het readxl package gebruiken. read-excel(path=‘path/to/file/excelworkbook.xls’) Deze functie heeft een optioneel argument sheet waarmee de excelsheet aangegeven kan worden indien het bestand er meerdere bevat. Eventueel kan met range ook een celbereik aangegeven worden. "],
["standaard-statistische-toetsen-voor-continue-data.html", "Hoofdstuk9 Standaard statistische toetsen voor continue data 9.1 Een steekproef 9.2 Twee steekproeven 9.3 Meer dan twee steekproeven 9.4 Standaard toetsen voor categorische data", " Hoofdstuk9 Standaard statistische toetsen voor continue data 9.1 Een steekproef De meest eenvoudige situatie waarin we een statistische toets kunnen gebruiken is misschien die waarbij we een steekproef hebben uit een populatie waarvan we aannemen dat een variabele een normale verdeling heeft. We willen de nulhypothese toetsen dat het gemiddelde van deze variabele gelijk is aan een bepaalde waarde. Een voorbeeld is als we een steekproef hebben van een aantal kinderen met een bepaald syndroom. We willen toetsen of het gemiddelde IQ van de kinderen met dit syndroom afwijkt van dat van andere kinderen (dus van 100). De IQ scores die we gemeten hebben waren: 74, 87, 100, 75, 98, 74, 79, 103, 95 en 110. We willen de nulhypothese dat het gemiddelde 100 is toetsen met een alpha van 5%. Dat wil zeggen dat als de nulhypothese waar is er toch 5% kans is dat we de nulhypothese (onterecht) verwerpen. Eigenlijk zouden we er natuurlijk een statisticus moeten raadplegen om te kijken hoe groot de kans is om de nulhypothese te verwerpen als er wel een klinisch relevant verschil is maar daar gaan we nu niet op in. In R kunnen we de toets uitvoeren door middel van de t.test functie. IQs&lt;-c(74, 87, 100, 75, 98, 74, 79, 103, 95, 110) t.test(IQs, mu=100) ## ## One Sample t-test ## ## data: IQs ## t = -2.473, df = 9, p-value = 0.0354 ## alternative hypothesis: true mean is not equal to 100 ## 95 percent confidence interval: ## 79.89508 99.10492 ## sample estimates: ## mean of x ## 89.5 In de output zien we dat het gemiddelde IQ in de steekproef 89.5 was, een verschil van meer dan 10 punten ten opzichte van de referentiewaarde van 100 waarmee we vergeleken. De p-waarde is 0.035 en we kunnen de nulhypothese verwerpen. We zien dat het betrouwbaarheidsinterval loopt van 79.9 tot 99.1, onze schatting op basis van deze kleine steekproef is dus niet heel precies. 9.2 Twee steekproeven 9.2.1 Ongepaarde data Waarschijnlijk is de meest voorkomende situatie waarin we een statistische toets gebruiken die waarbij we twee groepen hebben waartussen we een uitkomst willen vergelijken waarbij we aannemen dat deze bij benadering normaal verdeeld is. In deze situatie kunnen we de t-toets voor ongepaarde data gebruiken. Stel je bijvoorbeeld voor dat we een trial hebben waarin we een pijnscore tussen de twee armen van de trial vergelijken. We hebben hiervan een voorbeeld dataset gemaakt. We hebben deze opgeslagen in de data.frame pain. We kunnen de t-toets voor ongepaarde data uitvoeren met hetzelfde commando, t.test, als we eerder hebben gezien. library(foreign) pain &lt;- read.spss(file=&#39;data/pain.sav&#39;, to.data.frame=TRUE) ## re-encoding from UTF-8 t.test(painfu ~ treatm ,data=pain) ## ## Welch Two Sample t-test ## ## data: painfu by treatm ## t = 4.7809, df = 95.585, p-value = 6.32e-06 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 9.040738 21.879262 ## sample estimates: ## mean in group Placebo mean in group Active ## 49.72 34.26 We zien in de uitvoer van R dat het gemiddelde pijnniveau 50 was in de placebogroep terwijl de gemiddelde pijn 34 was in de actieve groep. Als de nulhypothese dat het gemiddelde pijnniveau gelijk is waar zou zijn zou de kans een dergelijk verschil te vinden heel klein zijn zoals aangegeven wordt door de p-waarde. We verwerpen dus deze nulhypothese en concluderen dat de behandeling de pijn vermindert. We hebben hier de variant van de t-toets gebruikt waar we de aanname dat de variantie is beide groepen gelijk is niet hoeven te maken (dit wordt ook wel de Welch-toets genoemd). In de klassieke t-tets zoals deze in de meeste statistische leerboeken staat wordt deze aanname wel gemaakt. Wanneer we deze variant in R willen uitvoeren kunnen we dit aangeven met een extra argument var.equal=TRUE aan de functie t-test. 9.2.2 Gepaarde data In ons voorbeeld zou het ook interessant zijn om te zien of de pijn bij de follow-up meting lager is dan die op de baseline. Dit kan echter niet met de t-toets zoals we die hierboven hebben besproken omdat de patiënten bij de follow-up dezelfde zijn als die bij de baseline meting. We hebben hier de t-toets nodig voor gepaarde data (Eigenlijk is dit gewoon een t-toets voor een steekproef toegepast op het verschil tussen de twee metingen). We passen de toets toe in de placebogroep. data_placebo &lt;- pain[pain$treatm==&#39;Placebo&#39;,] with(data_placebo, t.test(x=painbl, y=painfu)) ## ## Welch Two Sample t-test ## ## data: painbl and painfu ## t = 2.1923, df = 97.941, p-value = 0.03072 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## 0.7148663 14.3651337 ## sample estimates: ## mean of x mean of y ## 57.26 49.72 We zien dat de pijnscore is afgenomen met 7.5 punten, hetgeen statistisch significant is. 9.3 Meer dan twee steekproeven De t-toets voor onafhankelijke steekproeven kan gegeneraliseerd worden om meer dan twee groepen te vergelijken. Dit noemen we ANOVA (ANalysis Of VAriance, oftewel variantieanalyse in het Nederlands). De nulhypothese die we toetsen is dat alle groepsgemiddelden gelijk zijn. Deze hypothese wordt getoetst door de variantie die er is in de gemiddelden van de groepen te vergelijken met de variantie binnen de groepen, vandaar de naam van de methode. Wanneer de nulhypothese niet waar is verwachten we dat de variantie in groepsgemiddelden relatief groet is. Laten we R gebruiken om te kijken of de baseline pijnscore verschilt tussen de verschillende etniciteiten: anova_eth &lt;- aov(painbl ~ race, data=pain) summary(anova_eth) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## race 2 9 4.63 0.018 0.982 ## Residuals 97 25171 259.49 Hier kunnen we de nulhypothese niet verwerpen;Er is geen bewijs dat de pijn bij aanvang verschilt tussen de etniciteiten. 9.4 Standaard toetsen voor categorische data Wanneer de uitkomst categorisch is in plaats van continu kunnen we de bovenstaande toetsen niet gebruiken. Er zijn echter alternatieven. 9.4.1 Een steekproef Stel dat we willen toetsen of de fractie mannen in onze trial gelijk is aan 0.5 (en dus gelijk aan die van vrouwen). In R kunnen we nu gebruik maken van de functie prop.test(x, n, p). Hier is x het aantal ‘events’ (dat wil zeggen mannen), n is het totaal aantal personen in het onderzoek en p is de (vaste) proportie waarmee we de vergelijking maken. # Kruistabel mken table(pain$sex) ## ## Male Female ## 70 30 prop.test(sum(pain$sex==&#39;Male&#39;), n=NROW(pain), p = 0.5) ## ## 1-sample proportions test with continuity correction ## ## data: sum(pain$sex == &quot;Male&quot;) out of NROW(pain), null probability 0.5 ## X-squared = 15.21, df = 1, p-value = 9.619e-05 ## alternative hypothesis: true p is not equal to 0.5 ## 95 percent confidence interval: ## 0.5989396 0.7854574 ## sample estimates: ## p ## 0.7 We zien aan de uitvoer dat 70% van de personen in ons onderzoek mannen zijn, het bijbehorende betrouwbaarheidsinterval loopt van 60% tot 79%. Het is dus duidelijk dat het percentage significant hoger ligt dan 50%. We krijgen hetzelfde resultaat door de functie prop.test toe te passen op de frequentietabel. prop.test(table(pain$sex)) 9.4.2 Twee (of meer) onafhankelijke steekproeven We kunnen de functie prop.test ook gebruiken om een proportie te vergelijken tussen twee groepen. Dit wordt de chi-kwadraat toets genoemd. Laten we kijken of het percentage mannen gelijk is in de twee armen van de trial. (tab &lt;- table(pain$treatm, pain$sex)) ## ## Male Female ## Placebo 34 16 ## Active 36 14 prop.test(tab) ## ## 2-sample test for equality of proportions with continuity correction ## ## data: tab ## X-squared = 0.047619, df = 1, p-value = 0.8273 ## alternative hypothesis: two.sided ## 95 percent confidence interval: ## -0.2394625 0.1594625 ## sample estimates: ## prop 1 prop 2 ## 0.68 0.72 Aan de output kunnen we zien dat het percentage mannen niet veel verschilt tussen de armen. We kunnen de nulhypothese van geen verschil hier dus niet verwerpen. Dezelfde toets kan ook worden toegepast wanneer we meer dan twee groepen hebben. (tab &lt;- table(pain$race, pain$sex)) ## ## Male Female ## Asian 11 3 ## Black 10 3 ## Caucasian 49 24 prop.test(tab) ## Warning in prop.test(tab): Chi-squared approximation may be incorrect ## ## 3-sample test for equality of proportions without continuity ## correction ## ## data: tab ## X-squared = 1.0742, df = 2, p-value = 0.5844 ## alternative hypothesis: two.sided ## sample estimates: ## prop 1 prop 2 prop 3 ## 0.7857143 0.7692308 0.6712329 In dit geval geeft R ons een waarschuwing. Dit komt omdat de (verwachte) aantallen in onze kruistabel hier erg laag zijn. Dit zorgt ervoor dat de benadering die gebruikt wordt voor de verdeling die de toetsingsgrootheid heeft onder de nulverdeling niet erg nauwkeurig is. 9.4.3 Twee afhankelijke steekproeven. Wanneer we gepaarde proporties willen vergelijken kunnen we de McNemar toets toepassen. We gebruiken deze toets hier om te kijken of de fractie mensen met een pijnscore lager dan 50 verschilt tussen de baseline en de follow-upmeting. pain$painbl50 &lt;- pain$painbl &gt; 50 pain$painfu50 &lt;- pain$painfu &gt; 50 (tab &lt;- table(pain$painbl50, pain$painfu50)) ## ## FALSE TRUE ## FALSE 27 12 ## TRUE 37 24 mcnemar.test(tab) ## ## McNemar&#39;s Chi-squared test with continuity correction ## ## data: tab ## McNemar&#39;s chi-squared = 11.755, df = 1, p-value = 0.0006068 In de McNemartoets wordt alleen naar de discordante paren gekeken. Dat wil zeggen dat de paren waarbij de uitkomst hetzelfde is worden niet benut. De vraag is of er meer mensen zijn die een hoge pijnscore hebben op baseline en niet bij de follow-up meting dan omgekeerd. Dit lijkt hier het geval te zijn en we kunnen de nulhypothese verwerpen dat deze proportie gelijk zou zijn. Flowchart "],
["plaatjes.html", "Hoofdstuk10 Plaatjes 10.1 Histogrammen 10.2 Circel- en staafdiagrammen en dotcharts 10.3 Algemene elementen van figuren in R 10.4 Lower-level plot functies", " Hoofdstuk10 Plaatjes We krijgen vaak meer inzicht in een data set door het maken van enkele goedgekozen plaatjes dan door het bekijken van tabellen van kengetallen. We zullen hier enkele R commando’s beschrijven die hiervoor van nut kunnen zijn. Er zijn verschillende R packages om plaatjes te maken. De belangrijkste zijn: * * lattice * ggplot2 We zullen hier de base graphics uit de graphics package bespreken. Deze plot functies kunnen verdeeld worden in twee types: de zogenoemde higher-level en lower-level plotting functies. Het verschil is dat de eerste een min of meer compleet plaatje maken en de laatste iets toevoegen aan een bestaand plaatje (zoals een referentielijn of een legenda). Vaak worden ingewikkelde plaatjes stap voor stap gemaakt door eerst een ‘higher-level’ functie te gebruiken en dan telkens elementen aan het plaatje toe te voegen. 10.1 Histogrammen Als we iets te weten willen komen over de verdeling van een variabele kunnen we een histogram maken. De functie om dit te doen in R is hist. laten we naar de pijnscores op het vervolgmoment kijken. hist(mydata$painfu) Wanneer we deze functie toepassen in RStudio zal in de rechter benedenhoek een plaatje weergegeven worden. We kunnen deze dan opslaan in bijvoorbeeld pdf of jpg formaat als we het resultaat willen bewaren. We kunnen het histogram verder aanpassen door bijvoorbeeld het aantal intervallen te veranderen door middel van de parameter breaks. hist(mydata$painfu, breaks=20) hist(mydata$painfu, breaks=seq(0,80,5)) 10.2 Circel- en staafdiagrammen en dotcharts Wanneer we willen kijken naar een de verdeling van een categorische variabele wordt vaak een cirkeldiagram gebruikt. De pie functie heeft als input een vector met frequenties nodig om een dergelijke afbeelding te maken, meestal samen met de labels. Vaak is het makkelijker om een table als input te gebruiken: pie(c(2, 4, 6), labels=c(&#39;foo&#39;, &#39;bar&#39;, &#39;buz&#39;) ) pie(table(mydata$race)) Er zijn mensen die cirkeldiagram afraden omdat mensen slecht zijn in het inschatten van de relatieve oppervlakten. Een zogenaamd dotchart kan een alternatief zijn. dotchart(c(2, 4, 6), labels=c(&#39;foo&#39;, &#39;bar&#39;, &#39;buz&#39;) ) dotchart(c(table(mydata$race))) Het was hier nodig om de tabel om te zetten naar een vector door de functie c te gebruiken. In plaats van een vector is het ook mogelijk om een matrix of twee-dimensionale tabel te gebruiken. dotchart(table(mydata$race, mydata$sex)) Een ander alternatief is een barchart (een figuur die lijkt op een histogram maar met een categorische variabele op de x-as). In R kunnen we een staafdiagram maken met de functie barplot. De namen van de verschillende categorieën moeten we nu specificeren met de parameter names.arg in plaats van labels. barplot(c(2, 4, 6), names.arg =c(&#39;foo&#39;, &#39;bar&#39;, &#39;buz&#39;) ) barplot(table(mydata$race)) Ook hier kunnen we weer een matrix of table gebruiken. barplot(table(mydata$race, mydata$sex)) Het zou natuurlijk beter zijn om een legenda aan de figuur toe te voegen om aan te geven wat de verschillende kleuren betekenen. We bespreken later hoe je dit zou kunnen doen. Het is ook mogelijk om de categorieën naast elkaar weer te geven: barplot(table(mydata$race, mydata$sex),beside = TRUE) ## Scatterplots Wanneer we naar het verband tussen twee continue variabelen willen kijken kan dat door een scatterplot te maken. In R kan dit door middel van de functie plot. plot(mydata$height, mydata$weight) Wanneer we slechts een enkele input vector gebruiken worden de waarnemingen uitgezet tegen de observatienummers. In dit geval is dat niet zo zinvol. plot(mydata$height) Soms willen we de relatie tussen verschillende continue variabelen in een keer laten zien. Dit kan met een zogenaamde scatterplotmatrix. Zoals de naam al aangeeft is dit een matrix waarbij in de cellen telkens de paarsgewijze combinaties van variabelen staan. pairs(~height+weight+painbl, data=mydata) 10.3 Algemene elementen van figuren in R De figuren die we hierboven hebben gemaakt zijn erg eenvoudig en zeker voor verbetering vatbaar. We kunnen veel veranderen aan de manier waarop de verschillende elementen worden weergegeven door extra argumenten te gebruiken in de plotfuncties. Deze grafische parameters om zaken als kleur, lijndikte, etc. aan te passen verschillen niet tussen de higher level plot functies. We zullen hier de belangrijkste bespreken. Een andere manier om deze eigenschappen van de plaatjes aan te passen is met behulp van de functie par. Enkele parameters kunnen zelfs alleen maar op deze manier worden aangepast. 10.3.1 col De parameter col wordt gebruikt om aan te geven in welke kleur iets geplot moet worden. Er zijn in R verschillende manieren om kleuren te specificeren. De eerste is om de naam van de kleur te gebruiken als een character waarde. Je kan zien welke namen voor kleuren R kent door middel van de functie colors(). plot(mydata$height, col=&#39;red&#39;) Een tweede manier om kleuren aan te geven is door middel van gehele getallen. Deze getallen Deze waarden corresponderen met de positie in het kleurenpalet dat R gebruikt. Standaard is 1 zwart, 2 rood, 3 groen, 4 blauw, 5 cyaan, 6 magenta, 7 geel en 8 grijs. Het kleurenpalet kan weergegeven of gewijzigd worden door middel van de palette functie. Een laatste manier om kleuren te specificeren is door middel van een hexadecimale kleurwaarde(dwz 16-tallig stelsel, er wordt niet met tien cijfers maar met zestien cijfers gewerkt, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E en F). Het komt erop neer dat er een tekstwaarde gebruikt wordt waarbij de eerste twee tekens de intensiteit van het rode signaal aangeven op een schaal van 0 tot 255, de volgende twee tekens de intensiteit van het groene signaal en het vijfde en zesde teken de intensiteit van het blauwe signaal. plot(mydata$height, col=&#39;#AA11AA&#39;) 10.3.2 pch Met pch wordt het symbool aangegeven dat voor de plot gebruikt wordt Meestal worden gehele getallen gebruikt waarbij elk getal staat voor een specifiek symbool. plot(x=1:16, 1:16, pch=1:16) 10.3.3 cex Met de parameter cex geven we aan hoe groot de symbolen en tekst moeten zijn. plot(x=seq(-1,1,0.25), y=seq(-1,1,0.25), cex=exp(seq(-1,1,0.25))) 10.3.4 lwd De parameter lwd geeft aan hoe dik de lijnen moeten zijn. 10.3.5 lty Met lty wordt het lijntype aangegeven: 1 is een doorgetrokken lijn, 2 is gestreept en 3 gestippeld. Er zijn ook complexere lijnstijlen mogelijk (zie ?par). 10.3.6 xlim / ylim Met xlim en ylim wordt aangegeven bij welke waarden de assen beginnen/ stoppen. Standaard zal R het plotbereik een klein beetje groter maken zodat de extremen niet precies op de rand van de plot vallen. 10.3.7 xlab / ylab Met xlab en ylab kan gespecificeerd worden wat de labels zijn van de x-as en y-as van de plot. 10.3.8 main Met de parameter main wordt aangegeven wat de titel van de plot moet zijn. Het is een alternatief voor de functie title(). 10.3.9 mar Met mar kunnen we de marges van de plot (in ‘regels’ aangeven). We kunnen de marges alleen veranderen door middel van de functie par() . Deze parameter moet bestaan uit een vector van precies vier waarden, de vier getallen staan voor respectievelijk de ondermarge, de linkermarge, de bovenmarge en de rechtermarge. 10.3.10 mfow Met de parameter mfrow specificeren we het aantal subplots. Dit is er normaal slechts een maar dit kan veranderd worden. mfrow kunnen we alleen instellen met behulp van de functie par. De parameter mfow moet bestaan uit een vector van lengte twee waarbij het eerste getal het aantal rijen van subplots aangeeft en het tweede getal het aantal kolommen. opar &lt;- par(mfrow=c(1, 2)) hist(mydata$height, col=&#39;red&#39;) hist(mydata$weight, col=&#39;blue&#39;) par(opar) Let op hoe we par hierboven gebruiken om de grafische parameters weer naar terug te zetten naar de waarden die ze hadden voor we ze aanpasten. 10.4 Lower-level plot functies Met de lower-level functies kunnen we elementen aan een bestaand plaatje toevoegen. Voorbeelden van deze functies zijn: 10.4.1 points(x, y, …) Om punten toe te voegen aan een plaatje. 10.4.2 lines(x, y, …) Om lijnen toe te voegen aan een plaatje. 10.4.3 text(x, y, labels, …) Om lijnen toe te voegen aan een plaatje. 10.4.4 abline(…) Met deze functie kunnen we een referentielijn toevoegen. We kunnen een horizontale lijn maken met abline(h=y) een verticale lijn met abline(v=x). En diagonale lijn y=a *x + b kunnen we maken met abline(a=a, b=b) (hier komt ook de naam van de functie vandaan). 10.4.5 legend(x, y, legend, …) Met deze functie kun je een legenda toevoegen aan een plaatje. Behalve x-, en y-coördinaten kunnen we de positie ook aangeven door middel van de tekstwaarden als ‘top’, ‘bottom’, ‘left’ en ‘right’. 10.4.6 title(main, sub, …) Hiermee kunnen we een titel en ondertitel aan een plaatje toevoegen. "],
["overzicht-functies.html", "Hoofdstuk11 Overzicht functies", " Hoofdstuk11 Overzicht functies ##dimensies Functie Omschrijving length Geeft lengte van een vector nrow aantal rijen in een matrix ncol aantal kolommen in een matrix NROW als nrow maar een vector wordt gezien als een matrix met 1-kolom NCOL als ncol maar een vector wordt gezien als een matrix met 1-kolom dim geeft dimensies van een object (meestal matrix of array) als vector ##beschrijvende statistiek Functie Omschrijving sum som van waarden mean gemiddelde van waarden median mediaan van waarden (meestal numerieke vector) quantile kwantielen vannumerieke vector var bereken variantie van numerieke vector of matrix of data.frame cov bereken covariantie van matrix of data.frame sd bereken standaarddeviatie van numerieke vector cor bereken correlatie van matrix of data.frame min bereken minimum waarde van object (meestal numerieke vector) max bereken maximumwaarde van object (meestal numerieke vector) range bereken minimum en maximum pmin gevectoriseerde versie van min pmax gevectoriseerde versie van max ave bereken summary statistic voor subgroepen ##wiskunde Functie Omschrijving log bereken natuurlijk logaritme (of logaritme met bepaald grondtal) log2, log10 logariathme met grondtal 2 of 10 exp anti-logaritme (e-macht) cos, sin, tan standaard trigonometrische functies sort sorteert input vector rev zet vector in omgekeerde volgorde rank Geeft rangnummers van observaties order Geeft indices die gebruikt kunnen worden om de invoer te sorteren ##sequenties Functie Omschrijving duplicated Geeft van alle observaties aan of ze eerder voorkwamen seq Maak een sequentie van waarden (zoals bijv. 2,3,4,5 ) rep Herhaald invoer een aantal keer ##tekst Functie Omschrijving paste Plak character waarden aan elkaar (standaard gescheiden door een spatie) paste0 Als paste maar zonder scheidingsteken substr Haalt een gedeelte (substring) uit een character vector nchar Aantal karakters in een character waarde "],
["references.html", "References", " References "]
]
